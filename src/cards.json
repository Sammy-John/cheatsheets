[
    {
      "id": "syntax-using-system",
      "topic": "Syntax",
      "category": "Imports",
      "title": "using System;",
      "description": "Includes core system functionality such as Console, Math, String, etc.",
      "code": "using System;\n\nConsole.WriteLine(\"Hello, World!\");",
      "tags": ["syntax", "using", "core"]
    },
    {
      "id": "syntax-using-system-collections-generic",
      "topic": "Syntax",
      "category": "Imports",
      "title": "using System.Collections.Generic;",
      "description": "Enables usage of generic collections like List<T>, Dictionary<TKey, TValue>.",
      "code": "using System.Collections.Generic;\n\nList<string> names = new List<string>();",
      "tags": ["syntax", "using", "collections"]
    },
    {
      "id": "syntax-using-system-linq",
      "topic": "Syntax",
      "category": "Imports",
      "title": "using System.Linq;",
      "description": "Provides LINQ functionality to query collections using a functional approach.",
      "code": "using System.Linq;\n\nvar evenNumbers = numbers.Where(n => n % 2 == 0);",
      "tags": ["syntax", "using", "linq"]
    },
    {
      "id": "syntax-using-system-text",
      "topic": "Syntax",
      "category": "Imports",
      "title": "using System.Text;",
      "description": "Gives access to classes for string encoding and StringBuilder.",
      "code": "using System.Text;\n\nStringBuilder sb = new StringBuilder();",
      "tags": ["syntax", "using", "string"]
    },
    {
      "id": "syntax-using-system-threading",
      "topic": "Syntax",
      "category": "Imports",
      "title": "using System.Threading;",
      "description": "Provides classes and methods for multithreading.",
      "code": "using System.Threading;\n\nThread.Sleep(1000);",
      "tags": ["syntax", "using", "threads"]
    },
    {
      "id": "syntax-using-system-io",
      "topic": "Syntax",
      "category": "Imports",
      "title": "using System.IO;",
      "description": "Used for file and stream I/O operations.",
      "code": "using System.IO;\n\nFile.WriteAllText(\"file.txt\", \"Hello\");",
      "tags": ["syntax", "using", "io"]
    },
      {
        "id": "syntax-namespace-declaration",
        "topic": "Syntax",
        "category": "Program Structure",
        "title": "namespace Declaration",
        "description": "Defines a scope to group related classes and avoid naming conflicts.",
        "code": "namespace MyApplication\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello from MyApplication!\");\n        }\n    }\n}",
        "tags": ["syntax", "structure", "namespace"]
      },
      {
        "id": "syntax-class-declaration",
        "topic": "Syntax",
        "category": "Program Structure",
        "title": "class Declaration",
        "description": "Defines a class as the core building block of a C# program. Can contain methods, properties, and fields.",
        "code": "public class Calculator\n{\n    public int Add(int a, int b)\n    {\n        return a + b;\n    }\n}",
        "tags": ["syntax", "structure", "class"]
      },
      {
        "id": "syntax-entry-point-main-method",
        "topic": "Syntax",
        "category": "Program Structure",
        "title": "Entry Point: static void Main(string[] args)",
        "description": "The starting point of a C# console application. Executes when the program runs.",
        "code": "static void Main(string[] args)\n{\n    Console.WriteLine(\"Welcome to the program!\");\n}",
        "tags": ["syntax", "structure", "entry point", "main"]
      },
      {
        "id": "syntax-method-declaration",
        "topic": "Syntax",
        "category": "Program Structure",
        "title": "Method Declaration",
        "description": "Defines a reusable block of code. Includes access modifiers, return type, method name, and parameters.",
        "code": "public void GreetUser(string name)\n{\n    Console.WriteLine($\"Hello, {name}!\");\n}",
        "tags": ["syntax", "structure", "method", "function"]
      },
      {
        "id": "syntax-static-method-declaration",
        "topic": "Syntax",
        "category": "Program Structure",
        "title": "Static Method Declaration",
        "description": "A method that belongs to the class itself rather than to instances of the class.",
        "code": "public static int Square(int number)\n{\n    return number * number;\n}",
        "tags": ["syntax", "structure", "method", "static"]
      },
        {
          "id": "syntax-if-statement",
          "topic": "Syntax",
          "category": "Control Flow",
          "title": "if Statement",
          "description": "Executes a block of code if a specified condition is true.",
          "code": "if (score >= 50)\n{\n    Console.WriteLine(\"You passed!\");\n}",
          "tags": ["syntax", "control flow", "if", "conditional"]
        },
        {
          "id": "syntax-if-else-statement",
          "topic": "Syntax",
          "category": "Control Flow",
          "title": "if-else Statement",
          "description": "Executes one block of code if the condition is true, another block if the condition is false.",
          "code": "if (score >= 50)\n{\n    Console.WriteLine(\"You passed!\");\n}\nelse\n{\n    Console.WriteLine(\"You failed.\");\n}",
          "tags": ["syntax", "control flow", "if", "else", "conditional"]
        },
        {
          "id": "syntax-else-if-statement",
          "topic": "Syntax",
          "category": "Control Flow",
          "title": "else-if Ladder",
          "description": "Checks multiple conditions in sequence and executes the first true block.",
          "code": "if (score >= 90)\n{\n    Console.WriteLine(\"Grade: A\");\n}\nelse if (score >= 80)\n{\n    Console.WriteLine(\"Grade: B\");\n}\nelse\n{\n    Console.WriteLine(\"Grade: C or below\");\n}",
          "tags": ["syntax", "control flow", "if", "else if", "conditional"]
        },
        {
          "id": "syntax-switch-statement",
          "topic": "Syntax",
          "category": "Control Flow",
          "title": "switch Statement",
          "description": "Selects one of many code blocks to be executed based on a matching value.",
          "code": "switch (day)\n{\n    case \"Monday\":\n        Console.WriteLine(\"Start of the week!\");\n        break;\n    case \"Friday\":\n        Console.WriteLine(\"Weekend is near!\");\n        break;\n    default:\n        Console.WriteLine(\"Just another day.\");\n        break;\n}",
          "tags": ["syntax", "control flow", "switch", "conditional"]
        },
        {
          "id": "syntax-for-loop",
          "topic": "Syntax",
          "category": "Control Flow",
          "title": "for Loop",
          "description": "Executes a block of code a specific number of times.",
          "code": "for (int i = 0; i < 5; i++)\n{\n    Console.WriteLine($\"Iteration {i}\");\n}",
          "tags": ["syntax", "control flow", "loop", "for"]
        },
        {
          "id": "syntax-while-loop",
          "topic": "Syntax",
          "category": "Control Flow",
          "title": "while Loop",
          "description": "Repeats a block of code while a specified condition is true.",
          "code": "int count = 0;\nwhile (count < 3)\n{\n    Console.WriteLine($\"Count: {count}\");\n    count++;\n}",
          "tags": ["syntax", "control flow", "loop", "while"]
        },
        {
          "id": "syntax-do-while-loop",
          "topic": "Syntax",
          "category": "Control Flow",
          "title": "do-while Loop",
          "description": "Similar to a while loop, but guarantees the block runs at least once.",
          "code": "int number;\ndo\n{\n    Console.Write(\"Enter a number (0 to stop): \");\n    number = int.Parse(Console.ReadLine());\n} while (number != 0);",
          "tags": ["syntax", "control flow", "loop", "do while"]
        },
        {
          "id": "syntax-foreach-loop",
          "topic": "Syntax",
          "category": "Control Flow",
          "title": "foreach Loop",
          "description": "Iterates over each element in a collection or array.",
          "code": "string[] fruits = {\"Apple\", \"Banana\", \"Cherry\"};\nforeach (string fruit in fruits)\n{\n    Console.WriteLine(fruit);\n}",
          "tags": ["syntax", "control flow", "loop", "foreach"]
        },
        {
          "id": "syntax-break-statement",
          "topic": "Syntax",
          "category": "Control Flow",
          "title": "break Statement",
          "description": "Terminates the closest enclosing loop or switch statement immediately.",
          "code": "for (int i = 0; i < 10; i++)\n{\n    if (i == 5)\n    {\n        break;\n    }\n    Console.WriteLine(i);\n}",
          "tags": ["syntax", "control flow", "break", "loop"]
        },
        {
          "id": "syntax-continue-statement",
          "topic": "Syntax",
          "category": "Control Flow",
          "title": "continue Statement",
          "description": "Skips the current iteration of a loop and continues with the next iteration.",
          "code": "for (int i = 0; i < 5; i++)\n{\n    if (i == 2)\n    {\n        continue;\n    }\n    Console.WriteLine(i);\n}",
          "tags": ["syntax", "control flow", "continue", "loop"]
        },
        {
          "id": "syntax-int-type",
          "topic": "Syntax",
          "category": "Data Types",
          "title": "int",
          "description": "Stores whole numbers between -2,147,483,648 and 2,147,483,647.",
          "code": "int age = 30;\nConsole.WriteLine(age);",
          "tags": ["syntax", "data types", "int", "integer"]
        },
        {
          "id": "syntax-double-type",
          "topic": "Syntax",
          "category": "Data Types",
          "title": "double",
          "description": "Stores decimal numbers with double precision floating point.",
          "code": "double price = 19.99;\nConsole.WriteLine(price);",
          "tags": ["syntax", "data types", "double", "float"]
        },
        {
          "id": "syntax-bool-type",
          "topic": "Syntax",
          "category": "Data Types",
          "title": "bool",
          "description": "Stores true or false values.",
          "code": "bool isActive = true;\nConsole.WriteLine(isActive);",
          "tags": ["syntax", "data types", "bool", "boolean"]
        },
        {
          "id": "syntax-char-type",
          "topic": "Syntax",
          "category": "Data Types",
          "title": "char",
          "description": "Stores a single Unicode character.",
          "code": "char grade = 'A';\nConsole.WriteLine(grade);",
          "tags": ["syntax", "data types", "char", "character"]
        },
        {
          "id": "syntax-string-type",
          "topic": "Syntax",
          "category": "Data Types",
          "title": "string",
          "description": "Stores a sequence of characters (text).",
          "code": "string message = \"Hello, World!\";\nConsole.WriteLine(message);",
          "tags": ["syntax", "data types", "string", "text"]
        },
        {
          "id": "syntax-var-keyword",
          "topic": "Syntax",
          "category": "Data Types",
          "title": "var (Implicit Typing)",
          "description": "Infers the type from the assigned value (must be initialized).",
          "code": "var count = 10; // inferred as int\nConsole.WriteLine(count);",
          "tags": ["syntax", "data types", "var", "implicit"]
        },
        {
          "id": "syntax-const-keyword",
          "topic": "Syntax",
          "category": "Data Types",
          "title": "const",
          "description": "Declares an unchangeable (compile-time) constant.",
          "code": "const double Pi = 3.14159;\nConsole.WriteLine(Pi);",
          "tags": ["syntax", "data types", "const", "constant"]
        },
        {
          "id": "syntax-object-type",
          "topic": "Syntax",
          "category": "Data Types",
          "title": "object",
          "description": "Base type of all data types in C#. Can hold any type.",
          "code": "object data = 42;\nConsole.WriteLine(data);",
          "tags": ["syntax", "data types", "object", "base type"]
        },
        {
          "id": "syntax-dynamic-type",
          "topic": "Syntax",
          "category": "Data Types",
          "title": "dynamic",
          "description": "Stores any type and resolves at runtime (no compile-time type checking).",
          "code": "dynamic value = \"Hello\";\nvalue = 123;\nConsole.WriteLine(value);",
          "tags": ["syntax", "data types", "dynamic", "runtime"]
        },
        {
          "id": "syntax-decimal-type",
          "topic": "Syntax",
          "category": "Data Types",
          "title": "decimal",
          "description": "Precise decimal numbers for financial and monetary calculations.",
          "code": "decimal balance = 1000.75m;\nConsole.WriteLine(balance);",
          "tags": ["syntax", "data types", "decimal", "money"]
        },
        {
          "id": "syntax-method-declaration",
          "topic": "Syntax",
          "category": "Methods",
          "title": "Method Declaration",
          "description": "Defines a reusable block of code with a return type, name, and optional parameters.",
          "code": "public void SayHello()\n{\n    Console.WriteLine(\"Hello!\");\n}",
          "tags": ["syntax", "methods", "declaration", "void"]
        },
        {
          "id": "syntax-method-call",
          "topic": "Syntax",
          "category": "Methods",
          "title": "Calling a Method",
          "description": "Invoke a method by using its name followed by parentheses.",
          "code": "SayHello();",
          "tags": ["syntax", "methods", "call", "invoke"]
        },
        {
          "id": "syntax-method-parameters",
          "topic": "Syntax",
          "category": "Methods",
          "title": "Method with Parameters",
          "description": "Pass values to a method using parameters.",
          "code": "public void Greet(string name)\n{\n    Console.WriteLine($\"Hello, {name}!\");\n}",
          "tags": ["syntax", "methods", "parameters", "arguments"]
        },
        {
          "id": "syntax-method-return-value",
          "topic": "Syntax",
          "category": "Methods",
          "title": "Returning a Value",
          "description": "Methods can return values using a return type and the return keyword.",
          "code": "public int Add(int a, int b)\n{\n    return a + b;\n}",
          "tags": ["syntax", "methods", "return", "value"]
        },
        {
          "id": "syntax-method-overloading",
          "topic": "Syntax",
          "category": "Methods",
          "title": "Method Overloading",
          "description": "Multiple methods can share the same name if they differ in parameters.",
          "code": "public void Print(string message) { }\npublic void Print(int number) { }",
          "tags": ["syntax", "methods", "overloading", "parameters"]
        },
        {
          "id": "syntax-method-default-parameters",
          "topic": "Syntax",
          "category": "Methods",
          "title": "Default Parameters",
          "description": "Provide default values for parameters so they are optional when calling the method.",
          "code": "public void ShowMessage(string msg = \"Default\")\n{\n    Console.WriteLine(msg);\n}",
          "tags": ["syntax", "methods", "default", "optional parameters"]
        },
        {
          "id": "syntax-method-static",
          "topic": "Syntax",
          "category": "Methods",
          "title": "Static Methods",
          "description": "Belong to the class itself and can be called without an instance.",
          "code": "public static void Log(string message)\n{\n    Console.WriteLine(message);\n}",
          "tags": ["syntax", "methods", "static", "class method"]
        },
        {
          "id": "syntax-method-main",
          "topic": "Syntax",
          "category": "Methods",
          "title": "Main Method",
          "description": "The entry point of a C# application. Must be static.",
          "code": "static void Main(string[] args)\n{\n    Console.WriteLine(\"Program started.\");\n}",
          "tags": ["syntax", "methods", "main", "entry point"]
        },
        {
          "id": "syntax-method-async",
          "topic": "Syntax",
          "category": "Methods",
          "title": "Async Methods",
          "description": "Methods marked with async can use the await keyword for asynchronous operations.",
          "code": "public async Task LoadDataAsync()\n{\n    await Task.Delay(1000);\n    Console.WriteLine(\"Done.\");\n}",
          "tags": ["syntax", "methods", "async", "await"]
        },
        {
          "id": "syntax-ref-parameter",
          "topic": "Syntax",
          "category": "Advanced Method Syntax",
          "title": "ref Parameter",
          "description": "Allows a method to modify the caller’s variable directly.",
          "code": "void Modify(ref int number)\n{\n    number += 10;\n}\n\nint val = 5;\nModify(ref val);",
          "tags": ["syntax", "methods", "advanced", "ref", "parameter"]
        },
        {
          "id": "syntax-out-parameter",
          "topic": "Syntax",
          "category": "Advanced Method Syntax",
          "title": "out Parameter",
          "description": "Used to return multiple values from a method.",
          "code": "void GetValues(out int x, out int y)\n{\n    x = 10;\n    y = 20;\n}\n\nGetValues(out int a, out int b);",
          "tags": ["syntax", "methods", "advanced", "out", "multiple return"]
        },
        {
          "id": "syntax-in-parameter",
          "topic": "Syntax",
          "category": "Advanced Method Syntax",
          "title": "in Parameter",
          "description": "Passes a parameter by reference but does not allow modification.",
          "code": "void Show(in int value)\n{\n    Console.WriteLine(value);\n}",
          "tags": ["syntax", "methods", "advanced", "in", "readonly"]
        },
        {
          "id": "syntax-params-array",
          "topic": "Syntax",
          "category": "Advanced Method Syntax",
          "title": "params Array",
          "description": "Allows passing a variable number of arguments to a method.",
          "code": "void PrintNumbers(params int[] numbers)\n{\n    foreach (int n in numbers)\n        Console.WriteLine(n);\n}\n\nPrintNumbers(1, 2, 3);",
          "tags": ["syntax", "methods", "advanced", "params", "variable arguments"]
        },
        {
          "id": "syntax-expression-bodied-method",
          "topic": "Syntax",
          "category": "Advanced Method Syntax",
          "title": "Expression-Bodied Method",
          "description": "Concise method syntax for simple return expressions.",
          "code": "int Square(int x) => x * x;",
          "tags": ["syntax", "methods", "advanced", "expression bodied"]
        },
        {
          "id": "syntax-extension-method",
          "topic": "Syntax",
          "category": "Advanced Method Syntax",
          "title": "Extension Method",
          "description": "Adds a method to an existing type without modifying it directly.",
          "code": "public static class StringExtensions\n{\n    public static int WordCount(this string str)\n    {\n        return str.Split(' ').Length;\n    }\n}\n\nstring s = \"Hello world\";\nint count = s.WordCount();",
          "tags": ["syntax", "methods", "advanced", "extension method", "this"]
        },
        {
          "id": "syntax-local-function",
          "topic": "Syntax",
          "category": "Advanced Method Syntax",
          "title": "Local Function",
          "description": "A method defined inside another method.",
          "code": "void Outer()\n{\n    void Inner()\n    {\n        Console.WriteLine(\"Inside Inner\");\n    }\n    Inner();\n}",
          "tags": ["syntax", "methods", "advanced", "local function"]
        },
        {
          "id": "syntax-class-definition",
          "topic": "Syntax",
          "category": "Classes & Objects",
          "title": "Class Definition",
          "description": "Defines a blueprint for creating objects with fields, properties, and methods.",
          "code": "public class Person\n{\n    public string Name;\n    public void Greet() {\n        Console.WriteLine($\"Hello, {Name}!\");\n    }\n}",
          "tags": ["syntax", "class", "objects", "definition"]
        },
        {
          "id": "syntax-object-instantiation",
          "topic": "Syntax",
          "category": "Classes & Objects",
          "title": "Object Instantiation",
          "description": "Creates an instance of a class using the `new` keyword.",
          "code": "Person p = new Person();\np.Name = \"Sam\";\np.Greet();",
          "tags": ["syntax", "objects", "new", "instantiation"]
        },
        {
          "id": "syntax-constructor",
          "topic": "Syntax",
          "category": "Classes & Objects",
          "title": "Constructor",
          "description": "Special method that runs when a new object is created.",
          "code": "public class Person\n{\n    public string Name;\n    public Person(string name) {\n        Name = name;\n    }\n}",
          "tags": ["syntax", "class", "constructor", "objects"]
        },
        {
          "id": "syntax-access-modifiers",
          "topic": "Syntax",
          "category": "Classes & Objects",
          "title": "Access Modifiers",
          "description": "Control visibility of class members using `public`, `private`, etc.",
          "code": "public class Car {\n    private int speed;\n    public void Accelerate() {\n        speed += 10;\n    }\n}",
          "tags": ["syntax", "access", "modifiers", "public", "private"]
        },
        {
          "id": "syntax-this-keyword",
          "topic": "Syntax",
          "category": "Classes & Objects",
          "title": "this Keyword",
          "description": "Refers to the current instance of the class.",
          "code": "public class Box {\n    private int width;\n    public Box(int width) {\n        this.width = width;\n    }\n}",
          "tags": ["syntax", "this", "keyword", "objects"]
        },
        {
          "id": "syntax-properties",
          "topic": "Syntax",
          "category": "Classes & Objects",
          "title": "Auto-Implemented Properties",
          "description": "Simplified syntax for defining public properties with getters/setters.",
          "code": "public class User {\n    public string Name { get; set; }\n}",
          "tags": ["syntax", "properties", "get", "set"]
        },
        {
          "id": "syntax-static-class",
          "topic": "Syntax",
          "category": "Classes & Objects",
          "title": "Static Class",
          "description": "A class that cannot be instantiated and only contains static members.",
          "code": "public static class MathHelper\n{\n    public static int Double(int x)\n    {\n        return x * 2;\n    }\n}\n\nint result = MathHelper.Double(4);",
          "tags": ["syntax", "static", "class", "utility"]
        },
        {
          "id": "syntax-object-initializer",
          "topic": "Syntax",
          "category": "Classes & Objects",
          "title": "Object Initializer",
          "description": "Creates an object and sets its properties in a single expression.",
          "code": "Person p = new Person {\n    Name = \"Alex\",\n    Age = 28\n};",
          "tags": ["syntax", "object", "initializer", "properties"]
        },
        {
          "id": "syntax-inheritance",
          "topic": "Syntax",
          "category": "OOP Concepts",
          "title": "Inheritance",
          "description": "Allows a class to inherit fields and methods from another class.",
          "code": "public class Animal {\n    public void Speak() {\n        Console.WriteLine(\"Sound\");\n    }\n}\n\npublic class Dog : Animal { }",
          "tags": ["syntax", "oop", "inheritance"]
        },
        {
          "id": "syntax-virtual-override",
          "topic": "Syntax",
          "category": "OOP Concepts",
          "title": "virtual and override",
          "description": "Used to override a method in a derived class.",
          "code": "public class Animal {\n    public virtual void Speak() {\n        Console.WriteLine(\"Sound\");\n    }\n}\n\npublic class Dog : Animal {\n    public override void Speak() {\n        Console.WriteLine(\"Bark\");\n    }\n}",
          "tags": ["syntax", "oop", "virtual", "override"]
        },
        {
          "id": "syntax-abstract-class",
          "topic": "Syntax",
          "category": "OOP Concepts",
          "title": "Abstract Class",
          "description": "Cannot be instantiated and may contain abstract (must override) members.",
          "code": "public abstract class Shape {\n    public abstract double Area();\n}\n\npublic class Circle : Shape {\n    public override double Area() => 3.14 * 4 * 4;\n}",
          "tags": ["syntax", "oop", "abstract", "class"]
        },
        {
          "id": "syntax-interface",
          "topic": "Syntax",
          "category": "OOP Concepts",
          "title": "Interface",
          "description": "Defines a contract. A class must implement all members of the interface.",
          "code": "public interface IDrive {\n    void Start();\n}\n\npublic class Car : IDrive {\n    public void Start() {\n        Console.WriteLine(\"Engine on\");\n    }\n}",
          "tags": ["syntax", "oop", "interface", "contract"]
        },
        {
          "id": "syntax-sealed-class",
          "topic": "Syntax",
          "category": "OOP Concepts",
          "title": "Sealed Class",
          "description": "Prevents a class from being inherited.",
          "code": "public sealed class Config {\n    public string Name { get; set; }\n}",
          "tags": ["syntax", "oop", "sealed", "inheritance"]
        },
        {
          "id": "syntax-base-keyword",
          "topic": "Syntax",
          "category": "OOP Concepts",
          "title": "base Keyword",
          "description": "Calls a method or constructor from the parent class.",
          "code": "public class Animal {\n    public virtual void Speak() {\n        Console.WriteLine(\"Sound\");\n    }\n}\n\npublic class Dog : Animal {\n    public override void Speak() {\n        base.Speak();\n        Console.WriteLine(\"Bark\");\n    }\n}",
          "tags": ["syntax", "oop", "base", "inheritance"]
        },
        {
          "id": "syntax-polymorphism",
          "topic": "Syntax",
          "category": "OOP Concepts",
          "title": "Polymorphism",
          "description": "Allows objects to be treated as instances of their base type.",
          "code": "Animal animal = new Dog();\nanimal.Speak(); // Outputs: Bark",
          "tags": ["syntax", "oop", "polymorphism", "base class"]
        },
          {
            "id": "syntax-array-declaration",
            "topic": "Syntax",
            "category": "Collections & Arrays",
            "title": "Array Declaration",
            "description": "Fixed-size, strongly typed collection of elements.",
            "code": "int[] numbers = new int[] { 1, 2, 3, 4 };",
            "tags": ["syntax", "array", "collections"]
          },
          {
            "id": "syntax-array-access",
            "topic": "Syntax",
            "category": "Collections & Arrays",
            "title": "Array Access",
            "description": "Access elements in an array using zero-based indexing.",
            "code": "int first = numbers[0];\nConsole.WriteLine(first);",
            "tags": ["syntax", "array", "index", "access"]
          },
          {
            "id": "syntax-list-declaration",
            "topic": "Syntax",
            "category": "Collections & Arrays",
            "title": "List<T> Declaration",
            "description": "A dynamic, strongly typed generic list.",
            "code": "List<string> fruits = new List<string>();\nfruits.Add(\"Apple\");",
            "tags": ["syntax", "list", "collections", "generic"]
          },
          {
            "id": "syntax-dictionary-declaration",
            "topic": "Syntax",
            "category": "Collections & Arrays",
            "title": "Dictionary<TKey, TValue>",
            "description": "Stores key-value pairs for quick lookups.",
            "code": "Dictionary<string, int> scores = new Dictionary<string, int>();\nscores[\"Alice\"] = 90;",
            "tags": ["syntax", "dictionary", "collections", "key-value"]
          },
          {
            "id": "syntax-foreach-loop",
            "topic": "Syntax",
            "category": "Collections & Arrays",
            "title": "foreach Loop",
            "description": "Iterates over collections such as arrays or lists.",
            "code": "foreach (string fruit in fruits)\n{\n    Console.WriteLine(fruit);\n}",
            "tags": ["syntax", "loop", "foreach", "collections"]
          },
          {
            "id": "syntax-collection-initializer",
            "topic": "Syntax",
            "category": "Collections & Arrays",
            "title": "Collection Initializer",
            "description": "Creates and populates a collection in one statement.",
            "code": "var colors = new List<string> { \"Red\", \"Green\", \"Blue\" };",
            "tags": ["syntax", "collection", "initializer"]
          },
          {
            "id": "syntax-list-access",
            "topic": "Syntax",
            "category": "Collections & Arrays",
            "title": "Access List Elements",
            "description": "Use indexers to access elements from a list.",
            "code": "string firstColor = colors[0];",
            "tags": ["syntax", "list", "access", "index"]
          },
          {
            "id": "syntax-enum-definition",
            "topic": "Syntax",
            "category": "Enums & Structs",
            "title": "Enum Definition",
            "description": "Defines a set of named integral constants.",
            "code": "enum Status {\n    Pending,\n    Approved,\n    Rejected\n}",
            "tags": ["syntax", "enum", "enums", "definition"]
          },
          {
            "id": "syntax-enum-usage",
            "topic": "Syntax",
            "category": "Enums & Structs",
            "title": "Using an Enum",
            "description": "Use enum values like strongly typed constants.",
            "code": "Status current = Status.Approved;\nConsole.WriteLine(current);",
            "tags": ["syntax", "enum", "usage", "strong typing"]
          },
          {
            "id": "syntax-enum-explicit-values",
            "topic": "Syntax",
            "category": "Enums & Structs",
            "title": "Enum with Explicit Values",
            "description": "You can assign specific values to enum members.",
            "code": "enum Day {\n    Sunday = 1,\n    Monday = 2\n}",
            "tags": ["syntax", "enum", "custom values"]
          },
          {
            "id": "syntax-struct-definition",
            "topic": "Syntax",
            "category": "Enums & Structs",
            "title": "Struct Definition",
            "description": "A lightweight value type often used for small data models.",
            "code": "struct Point {\n    public int X;\n    public int Y;\n}",
            "tags": ["syntax", "struct", "value type"]
          },
          {
            "id": "syntax-struct-instantiation",
            "topic": "Syntax",
            "category": "Enums & Structs",
            "title": "Using a Struct",
            "description": "Create and use a struct like an object, but it’s passed by value.",
            "code": "Point p = new Point();\np.X = 5;\np.Y = 10;",
            "tags": ["syntax", "struct", "instantiate", "value type"]
          },
          {
            "id": "syntax-enum-to-int",
            "topic": "Syntax",
            "category": "Enums & Structs",
            "title": "Enum to Int",
            "description": "Enums can be cast to their underlying integer values.",
            "code": "int code = (int)Status.Approved;\nConsole.WriteLine(code);",
            "tags": ["syntax", "enum", "cast", "int"]
          },
          {
            "id": "syntax-enum-flags",
            "topic": "Syntax",
            "category": "Enums & Structs",
            "title": "[Flags] Enum",
            "description": "Allows combining enum values using bitwise operations.",
            "code": "[Flags]\nenum Permissions {\n    None = 0,\n    Read = 1,\n    Write = 2,\n    Execute = 4\n}\n\nPermissions p = Permissions.Read | Permissions.Write;",
            "tags": ["syntax", "enum", "flags", "bitwise"]
          },
          {
            "id": "syntax-readonly-struct",
            "topic": "Syntax",
            "category": "Enums & Structs",
            "title": "readonly struct",
            "description": "Prevents modification of struct fields after creation, improving performance and immutability.",
            "code": "public readonly struct Coordinate {\n    public int X { get; }\n    public int Y { get; }\n\n    public Coordinate(int x, int y) {\n        X = x;\n        Y = y;\n    }\n}",
            "tags": ["syntax", "struct", "readonly", "immutable"]
          },
          {
            "id": "syntax-try-catch",
            "topic": "Syntax",
            "category": "Exceptions & Error Handling",
            "title": "try-catch Block",
            "description": "Catches and handles exceptions thrown during execution.",
            "code": "try {\n    int x = 10 / 0;\n} catch (DivideByZeroException ex) {\n    Console.WriteLine(\"Cannot divide by zero.\");\n}",
            "tags": ["syntax", "exceptions", "try", "catch"]
          },
          {
            "id": "syntax-try-catch-finally",
            "topic": "Syntax",
            "category": "Exceptions & Error Handling",
            "title": "try-catch-finally",
            "description": "finally block runs regardless of whether an exception is thrown.",
            "code": "try {\n    // risky code\n} catch (Exception ex) {\n    Console.WriteLine(ex.Message);\n} finally {\n    Console.WriteLine(\"Cleanup\");\n}",
            "tags": ["syntax", "exceptions", "finally", "cleanup"]
          },
          {
            "id": "syntax-throw-exception",
            "topic": "Syntax",
            "category": "Exceptions & Error Handling",
            "title": "throw Keyword",
            "description": "Throws a new or rethrows an existing exception.",
            "code": "if (input == null) {\n    throw new ArgumentNullException(nameof(input));\n}",
            "tags": ["syntax", "exceptions", "throw", "error"]
          },
          {
            "id": "syntax-custom-exception",
            "topic": "Syntax",
            "category": "Exceptions & Error Handling",
            "title": "Custom Exception",
            "description": "You can define your own exception class by extending Exception.",
            "code": "public class MyException : Exception {\n    public MyException(string msg) : base(msg) {}\n}",
            "tags": ["syntax", "exceptions", "custom", "user-defined"]
          },
          {
            "id": "syntax-multiple-catch",
            "topic": "Syntax",
            "category": "Exceptions & Error Handling",
            "title": "Multiple catch Blocks",
            "description": "You can catch different exception types with multiple catch blocks.",
            "code": "try {\n    // code\n} catch (IOException ex) {\n    // file error\n} catch (Exception ex) {\n    // general\n}",
            "tags": ["syntax", "exceptions", "multiple catch"]
          },
          {
            "id": "syntax-rethrow-exception",
            "topic": "Syntax",
            "category": "Exceptions & Error Handling",
            "title": "Rethrow Exception",
            "description": "Use `throw;` to pass the exception up the call stack.",
            "code": "try {\n    // code\n} catch (Exception ex) {\n    Log(ex);\n    throw;\n}",
            "tags": ["syntax", "exceptions", "rethrow"]
          },
          {
            "id": "syntax-catch-when",
            "topic": "Syntax",
            "category": "Exceptions & Error Handling",
            "title": "catch with when Filter",
            "description": "Adds a condition to a catch block using `when`.",
            "code": "try {\n    // risky operation\n} catch (IOException ex) when (ex.Message.Contains(\"disk\")) {\n    Console.WriteLine(\"Disk-related IO error.\");\n}",
            "tags": ["syntax", "exceptions", "catch", "when", "filter"]
          },
          {
            "id": "syntax-exception-dispatch-info",
            "topic": "Syntax",
            "category": "Exceptions & Error Handling",
            "title": "ExceptionDispatchInfo.Capture",
            "description": "Preserves original exception stack trace when rethrowing.",
            "code": "try {\n    throw new InvalidOperationException();\n} catch (Exception ex) {\n    var edi = ExceptionDispatchInfo.Capture(ex);\n    // log or handle\n    edi.Throw();\n}",
            "tags": ["syntax", "exceptions", "dispatch", "preserve stacktrace"]
          },
    {
    "id": "syntax-namespace-definition",
    "topic": "Syntax",
    "category": "Namespaces",
    "title": "Namespace Definition",
    "description": "Organizes classes and types into logical groups.",
    "code": "namespace MyApp.Utilities {\n    class Logger {\n        // ...\n    }\n}",
    "tags": ["syntax", "namespace", "definition", "organization"]
  },
  {
    "id": "syntax-nested-namespaces",
    "topic": "Syntax",
    "category": "Namespaces",
    "title": "Nested Namespaces",
    "description": "Defines namespaces inside another to represent hierarchy.",
    "code": "namespace Company.Project.Module {\n    class Service {}\n}",
    "tags": ["syntax", "namespace", "nested", "hierarchy"]
  },
  {
    "id": "syntax-using-namespace",
    "topic": "Syntax",
    "category": "Namespaces",
    "title": "using Namespace",
    "description": "Imports types from a namespace to use without full qualification.",
    "code": "using System.Text;\n\nStringBuilder sb = new StringBuilder();",
    "tags": ["syntax", "using", "namespace", "import"]
  },
  {
    "id": "syntax-alias-namespace",
    "topic": "Syntax",
    "category": "Namespaces",
    "title": "Namespace Alias",
    "description": "Defines an alias for a namespace to shorten long references.",
    "code": "using Utils = MyCompany.Tools.Utilities;\n\nUtils.Logger.Log(\"Done\");",
    "tags": ["syntax", "alias", "namespace"]
  },
  {
    "id": "syntax-global-namespace",
    "topic": "Syntax",
    "category": "Namespaces",
    "title": "Global Namespace",
    "description": "Use `global::` to explicitly refer to the root namespace.",
    "code": "global::System.Console.WriteLine(\"Hello\");",
    "tags": ["syntax", "namespace", "global", "root"]
  },
  {
    "id": "syntax-const-definition",
    "topic": "Syntax",
    "category": "Constants & Readonly",
    "title": "const Keyword",
    "description": "Defines a compile-time constant value.",
    "code": "const double Pi = 3.14159;\nConsole.WriteLine(Pi);",
    "tags": ["syntax", "const", "constants"]
  },
  {
    "id": "syntax-readonly-field",
    "topic": "Syntax",
    "category": "Constants & Readonly",
    "title": "readonly Field",
    "description": "A field that can only be assigned during declaration or in a constructor.",
    "code": "class Circle {\n    public readonly double Radius;\n    public Circle(double r) {\n        Radius = r;\n    }\n}",
    "tags": ["syntax", "readonly", "field", "constructor"]
  },
  {
    "id": "syntax-static-readonly",
    "topic": "Syntax",
    "category": "Constants & Readonly",
    "title": "static readonly",
    "description": "Shared across all instances and set once at runtime.",
    "code": "public static readonly string AppName = \"Cheatsheet\";",
    "tags": ["syntax", "static", "readonly", "field"]
  },
  {
    "id": "syntax-const-vs-readonly",
    "topic": "Syntax",
    "category": "Constants & Readonly",
    "title": "const vs readonly",
    "description": "const is compile-time; readonly is runtime-settable (in constructor).",
    "code": "// const: compile-time\nconst int MaxUsers = 100;\n\n// readonly: runtime\nreadonly Guid Id = Guid.NewGuid();",
    "tags": ["syntax", "const", "readonly", "difference"]
  },
  {
    "id": "syntax-nullable-declaration",
    "topic": "Syntax",
    "category": "Nullable Types",
    "title": "Nullable Value Type",
    "description": "Use `?` to allow value types to hold `null`.",
    "code": "int? age = null;\nif (age.HasValue) {\n    Console.WriteLine(age.Value);\n}",
    "tags": ["syntax", "nullable", "value types", "null"]
  },
  {
    "id": "syntax-null-coalescing",
    "topic": "Syntax",
    "category": "Nullable Types",
    "title": "?? Null Coalescing",
    "description": "Provides a default value if the left-hand operand is null.",
    "code": "string name = inputName ?? \"Guest\";",
    "tags": ["syntax", "null", "coalescing", "default"]
  },
  {
    "id": "syntax-null-conditional",
    "topic": "Syntax",
    "category": "Nullable Types",
    "title": "?. Null Conditional",
    "description": "Safely access members without throwing if the target is null.",
    "code": "Console.WriteLine(user?.Profile?.Name);",
    "tags": ["syntax", "null", "conditional", "safe access"]
  },
  {
    "id": "syntax-null-forgiving",
    "topic": "Syntax",
    "category": "Nullable Types",
    "title": "! Null Forgiving",
    "description": "Suppresses compiler warnings about nullability.",
    "code": "string definitelyNotNull = maybeNull!;",
    "tags": ["syntax", "null", "suppress", "forgiving"]
  },
  {
    "id": "syntax-nullable-reference",
    "topic": "Syntax",
    "category": "Nullable Types",
    "title": "Nullable Reference Types",
    "description": "Enable nullable reference types to get static analysis support.",
    "code": "#nullable enable\nstring? name = null;\nConsole.WriteLine(name?.Length);",
    "tags": ["syntax", "null", "reference types", "nullable"]
  },
  {
    "id": "syntax-implicit-cast",
    "topic": "Syntax",
    "category": "Type Casting & Conversion",
    "title": "Implicit Casting",
    "description": "Automatically converts smaller types to larger compatible types.",
    "code": "int num = 10;\ndouble result = num; // Implicit cast",
    "tags": ["syntax", "casting", "implicit", "conversion"]
  },
  {
    "id": "syntax-explicit-cast",
    "topic": "Syntax",
    "category": "Type Casting & Conversion",
    "title": "Explicit Casting",
    "description": "Manually convert types that require confirmation (may lose data).",
    "code": "double d = 9.8;\nint i = (int)d;",
    "tags": ["syntax", "casting", "explicit", "manual"]
  },
  {
    "id": "syntax-as-keyword",
    "topic": "Syntax",
    "category": "Type Casting & Conversion",
    "title": "as Keyword",
    "description": "Attempts a safe cast to a reference type or nullable type, returns null if it fails.",
    "code": "object obj = \"hello\";\nstring str = obj as string;",
    "tags": ["syntax", "as", "casting", "safe", "nullable"]
  },
  {
    "id": "syntax-is-check",
    "topic": "Syntax",
    "category": "Type Casting & Conversion",
    "title": "is Keyword",
    "description": "Checks if an object is of a specific type.",
    "code": "if (obj is string s) {\n    Console.WriteLine(s);\n}",
    "tags": ["syntax", "is", "type check", "pattern"]
  },
  {
    "id": "syntax-convert-class",
    "topic": "Syntax",
    "category": "Type Casting & Conversion",
    "title": "Convert Class",
    "description": "Provides methods to convert between base types safely.",
    "code": "string str = \"123\";\nint num = Convert.ToInt32(str);",
    "tags": ["syntax", "convert", "class", "type"]
  },
  {
    "id": "syntax-tryparse",
    "topic": "Syntax",
    "category": "Type Casting & Conversion",
    "title": "TryParse Method",
    "description": "Safely attempts to parse a string into a type without throwing exceptions.",
    "code": "if (int.TryParse(\"42\", out int result)) {\n    Console.WriteLine(result);\n}",
    "tags": ["syntax", "parse", "tryparse", "safe"]
  },
  {
    "id": "syntax-obsolete-attribute",
    "topic": "Syntax",
    "category": "Attributes",
    "title": "[Obsolete] Attribute",
    "description": "Marks a method or class as outdated; shows a compile warning or error.",
    "code": "[Obsolete(\"Use NewMethod instead\")]\nvoid OldMethod() {\n    // ...\n}",
    "tags": ["syntax", "attribute", "obsolete", "warning"]
  },
  {
    "id": "syntax-attribute-basic",
    "topic": "Syntax",
    "category": "Attributes",
    "title": "Declaring an Attribute",
    "description": "Attributes are applied with square brackets above declarations.",
    "code": "[Serializable]\nclass MyData {\n    public int Id;\n}",
    "tags": ["syntax", "attribute", "serializable"]
  },
  {
    "id": "syntax-custom-attribute",
    "topic": "Syntax",
    "category": "Attributes",
    "title": "Custom Attribute",
    "description": "Create a new attribute by extending System.Attribute.",
    "code": "public class AuthorAttribute : Attribute {\n    public string Name;\n    public AuthorAttribute(string name) {\n        Name = name;\n    }\n}",
    "tags": ["syntax", "custom", "attribute", "metadata"]
  },
  {
    "id": "syntax-multiple-attributes",
    "topic": "Syntax",
    "category": "Attributes",
    "title": "Multiple Attributes",
    "description": "You can apply multiple attributes using commas or multiple brackets.",
    "code": "[Serializable, Obsolete]\nclass OldClass {}",
    "tags": ["syntax", "attribute", "multiple"]
  },
  {
    "id": "syntax-targeted-attribute",
    "topic": "Syntax",
    "category": "Attributes",
    "title": "Targeted Attribute",
    "description": "Attributes can be directed to specific parts like return types.",
    "code": "[return: NotNull]\npublic string? GetName() => name;",
    "tags": ["syntax", "attribute", "targeted", "return"]
  },
  {
    "id": "syntax-basic-lambda",
    "topic": "Syntax",
    "category": "Lambda Expressions",
    "title": "Basic Lambda",
    "description": "A concise way to represent an anonymous method.",
    "code": "Func<int, int> square = x => x * x;\nConsole.WriteLine(square(5));",
    "tags": ["syntax", "lambda", "expression", "anonymous function"]
  },
  {
    "id": "syntax-lambda-multiple-params",
    "topic": "Syntax",
    "category": "Lambda Expressions",
    "title": "Lambda with Multiple Parameters",
    "description": "Use parentheses for multiple parameters.",
    "code": "Func<int, int, int> add = (a, b) => a + b;\nConsole.WriteLine(add(2, 3));",
    "tags": ["syntax", "lambda", "parameters", "function"]
  },
  {
    "id": "syntax-lambda-block",
    "topic": "Syntax",
    "category": "Lambda Expressions",
    "title": "Lambda with Block Body",
    "description": "Use braces for multiple statements or return logic.",
    "code": "Func<int, int> doubleIt = x => {\n    Console.WriteLine(x);\n    return x * 2;\n};",
    "tags": ["syntax", "lambda", "block", "multiline"]
  },
  {
    "id": "syntax-lambda-in-linq",
    "topic": "Syntax",
    "category": "Lambda Expressions",
    "title": "Lambda in LINQ",
    "description": "Lambdas are frequently used in LINQ queries.",
    "code": "var evens = numbers.Where(n => n % 2 == 0).ToList();",
    "tags": ["syntax", "lambda", "linq", "filter"]
  },
  {
    "id": "syntax-action-lambda",
    "topic": "Syntax",
    "category": "Lambda Expressions",
    "title": "Action Delegate",
    "description": "Use `Action` when the lambda does not return a value.",
    "code": "Action<string> greet = name => Console.WriteLine($\"Hello, {name}\");\ngreet(\"Sam\");",
    "tags": ["syntax", "lambda", "action", "void"]
  },
  {
    "id": "syntax-is-pattern",
    "topic": "Syntax",
    "category": "Pattern Matching",
    "title": "is Pattern Matching",
    "description": "Checks type and declares variable if matched.",
    "code": "if (obj is string s) {\n    Console.WriteLine(s.Length);\n}",
    "tags": ["syntax", "pattern", "is", "type check"]
  },
  {
    "id": "syntax-switch-pattern",
    "topic": "Syntax",
    "category": "Pattern Matching",
    "title": "switch Expression Pattern",
    "description": "Pattern match using modern `switch` expressions.",
    "code": "string result = value switch {\n    1 => \"One\",\n    2 => \"Two\",\n    _ => \"Other\"\n};",
    "tags": ["syntax", "pattern", "switch", "expression"]
  },
  {
    "id": "syntax-relational-pattern",
    "topic": "Syntax",
    "category": "Pattern Matching",
    "title": "Relational Pattern",
    "description": "Match based on comparisons like `<`, `>=`, etc.",
    "code": "string msg = number switch {\n    < 0 => \"Negative\",\n    0 => \"Zero\",\n    > 0 => \"Positive\"\n};",
    "tags": ["syntax", "pattern", "relational", "switch"]
  },
  {
    "id": "syntax-logical-pattern",
    "topic": "Syntax",
    "category": "Pattern Matching",
    "title": "Logical Patterns",
    "description": "Combine patterns with `and`, `or`, and `not`.",
    "code": "if (x is > 0 and < 100) {\n    Console.WriteLine(\"In range\");\n}",
    "tags": ["syntax", "pattern", "logical", "and", "or", "not"]
  },
  {
    "id": "syntax-type-pattern",
    "topic": "Syntax",
    "category": "Pattern Matching",
    "title": "Type Pattern with Property",
    "description": "Use nested patterns to check properties inline.",
    "code": "if (person is { Age: > 18 }) {\n    Console.WriteLine(\"Adult\");\n}",
    "tags": ["syntax", "pattern", "nested", "property"]
  },
  {
    "id": "syntax-basic-tuple",
    "topic": "Syntax",
    "category": "Tuples & Deconstruction",
    "title": "Basic Tuple",
    "description": "A lightweight way to return multiple values.",
    "code": "var person = (\"Alice\", 30);\nConsole.WriteLine(person.Item1);",
    "tags": ["syntax", "tuple", "basic", "multiple values"]
  },
  {
    "id": "syntax-named-tuple",
    "topic": "Syntax",
    "category": "Tuples & Deconstruction",
    "title": "Named Tuple",
    "description": "Name tuple fields for more readable code.",
    "code": "var person = (Name: \"Alice\", Age: 30);\nConsole.WriteLine(person.Name);",
    "tags": ["syntax", "tuple", "named", "readability"]
  },
  {
    "id": "syntax-tuple-return",
    "topic": "Syntax",
    "category": "Tuples & Deconstruction",
    "title": "Return Tuple from Method",
    "description": "Use tuples to return multiple values from methods.",
    "code": "public (int sum, int diff) Calc(int a, int b) {\n    return (a + b, a - b);\n}",
    "tags": ["syntax", "tuple", "method", "return"]
  },
  {
    "id": "syntax-deconstruct-tuple",
    "topic": "Syntax",
    "category": "Tuples & Deconstruction",
    "title": "Deconstruct Tuple",
    "description": "Split tuple elements into separate variables.",
    "code": "var (name, age) = (\"Bob\", 25);\nConsole.WriteLine(name);",
    "tags": ["syntax", "deconstruct", "tuple", "destructure"]
  },
  {
    "id": "syntax-deconstruct-object",
    "topic": "Syntax",
    "category": "Tuples & Deconstruction",
    "title": "Deconstruct Custom Object",
    "description": "Define `Deconstruct` method to enable tuple-style unpacking.",
    "code": "public void Deconstruct(out string name, out int age) {\n    name = this.Name;\n    age = this.Age;\n}",
    "tags": ["syntax", "deconstruct", "custom", "object"]
  },
   {
    "id": "syntax-dynamic-type",
    "topic": "Syntax",
    "category": "Dynamic & ExpandoObject",
    "title": "dynamic Type",
    "description": "Bypasses compile-time type checking and resolves members at runtime.",
    "code": "dynamic message = \"Hello\";\nConsole.WriteLine(message.ToUpper());",
    "tags": ["syntax", "dynamic", "runtime", "type"]
  },
  {
    "id": "syntax-dynamic-behavior",
    "topic": "Syntax",
    "category": "Dynamic & ExpandoObject",
    "title": "Dynamic Behavior",
    "description": "Supports interop scenarios, reflection, and COM object manipulation.",
    "code": "dynamic excel = Activator.CreateInstance(Type.GetTypeFromProgID(\"Excel.Application\"));\nexcel.Visible = true;",
    "tags": ["syntax", "dynamic", "interop", "excel"]
  },
  {
    "id": "syntax-expandoobject",
    "topic": "Syntax",
    "category": "Dynamic & ExpandoObject",
    "title": "ExpandoObject",
    "description": "Allows you to dynamically add members to an object at runtime.",
    "code": "dynamic person = new ExpandoObject();\nperson.Name = \"Jane\";\nperson.Age = 28;",
    "tags": ["syntax", "expando", "dynamic", "runtime"]
  },
  {
    "id": "syntax-expando-method",
    "topic": "Syntax",
    "category": "Dynamic & ExpandoObject",
    "title": "ExpandoObject with Method",
    "description": "You can attach delegates to `ExpandoObject` members.",
    "code": "person.Speak = (Action)(() => Console.WriteLine(\"Hi!\"));\nperson.Speak();",
    "tags": ["syntax", "expando", "delegate", "method"]
  },
  {
    "id": "syntax-if-directive",
    "topic": "Syntax",
    "category": "Preprocessor Directives",
    "title": "#if / #endif",
    "description": "Conditionally compile code blocks based on symbols.",
    "code": "#define DEBUG\n\n#if DEBUG\nConsole.WriteLine(\"Debug Mode\");\n#endif",
    "tags": ["syntax", "preprocessor", "conditional", "#if"]
  },
  {
    "id": "syntax-define-directive",
    "topic": "Syntax",
    "category": "Preprocessor Directives",
    "title": "#define Directive",
    "description": "Defines a symbol for conditional compilation.",
    "code": "#define FEATURE_X\n\n#if FEATURE_X\nConsole.WriteLine(\"Feature Enabled\");\n#endif",
    "tags": ["syntax", "preprocessor", "#define"]
  },
  {
    "id": "syntax-region-directive",
    "topic": "Syntax",
    "category": "Preprocessor Directives",
    "title": "#region / #endregion",
    "description": "Organizes code into collapsible blocks in editors.",
    "code": "#region Utility Methods\nvoid Log(string msg) {\n    Console.WriteLine(msg);\n}\n#endregion",
    "tags": ["syntax", "preprocessor", "#region", "organization"]
  },
  {
    "id": "syntax-warning-directive",
    "topic": "Syntax",
    "category": "Preprocessor Directives",
    "title": "#warning / #error",
    "description": "Generates compile-time warnings or errors.",
    "code": "#warning Deprecated API usage\n#error Critical failure",
    "tags": ["syntax", "preprocessor", "#warning", "#error"]
  },
  {
    "id": "syntax-pragma-warning",
    "topic": "Syntax",
    "category": "Preprocessor Directives",
    "title": "#pragma warning",
    "description": "Disables or restores specific compiler warnings.",
    "code": "#pragma warning disable CS0168\nint unused;\n#pragma warning restore CS0168",
    "tags": ["syntax", "preprocessor", "#pragma", "warning"]
  },
  {
    "id": "syntax-auto-property",
    "topic": "Syntax",
    "category": "Indexers & Properties",
    "title": "Auto-Implemented Property",
    "description": "Simplifies property declaration with an implicit backing field.",
    "code": "public string Name { get; set; }",
    "tags": ["syntax", "property", "auto", "getter", "setter"]
  },
  {
    "id": "syntax-custom-property",
    "topic": "Syntax",
    "category": "Indexers & Properties",
    "title": "Custom Property",
    "description": "Define logic in `get` and `set` accessors.",
    "code": "private int _age;\npublic int Age {\n    get => _age;\n    set {\n        if (value >= 0) _age = value;\n    }\n}",
    "tags": ["syntax", "property", "get", "set", "custom logic"]
  },
  {
    "id": "syntax-readonly-property",
    "topic": "Syntax",
    "category": "Indexers & Properties",
    "title": "Read-Only Property",
    "description": "Property with a `get` accessor only (no `set`).",
    "code": "public DateTime Created { get; } = DateTime.Now;",
    "tags": ["syntax", "property", "readonly", "init"]
  },
  {
    "id": "syntax-init-property",
    "topic": "Syntax",
    "category": "Indexers & Properties",
    "title": "Init-Only Property",
    "description": "Allows assignment during object initialization only.",
    "code": "public string Title { get; init; }",
    "tags": ["syntax", "property", "init", "immutable"]
  },
  {
    "id": "syntax-indexer-basic",
    "topic": "Syntax",
    "category": "Indexers & Properties",
    "title": "Basic Indexer",
    "description": "Allow objects to be accessed like arrays.",
    "code": "public string this[int index] {\n    get => items[index];\n    set => items[index] = value;\n}",
    "tags": ["syntax", "indexer", "access", "array-like"]
  },
  {
    "id": "syntax-unsafe-keyword",
    "topic": "Syntax",
    "category": "Unsafe & Pointers",
    "title": "unsafe Keyword",
    "description": "Marks a block of code as unsafe for pointer operations.",
    "code": "unsafe {\n    int* p = &number;\n    Console.WriteLine(*p);\n}",
    "tags": ["syntax", "unsafe", "pointer", "memory"]
  },
  {
    "id": "syntax-fixed-statement",
    "topic": "Syntax",
    "category": "Unsafe & Pointers",
    "title": "fixed Statement",
    "description": "Pins a variable in memory to prevent GC from moving it.",
    "code": "fixed (int* p = &array[0]) {\n    Console.WriteLine(*p);\n}",
    "tags": ["syntax", "unsafe", "fixed", "gc", "memory"]
  },
  {
    "id": "syntax-pointer-declaration",
    "topic": "Syntax",
    "category": "Unsafe & Pointers",
    "title": "Pointer Declaration",
    "description": "Declares a pointer using the `*` symbol.",
    "code": "int* ptr;\nint value = 10;\nptr = &value;",
    "tags": ["syntax", "pointer", "declaration"]
  },
  {
    "id": "syntax-stackalloc",
    "topic": "Syntax",
    "category": "Unsafe & Pointers",
    "title": "stackalloc",
    "description": "Allocates memory on the stack instead of the heap.",
    "code": "Span<int> numbers = stackalloc int[5];",
    "tags": ["syntax", "stackalloc", "memory", "span"]
  },
  {
    "id": "syntax-enable-unsafe",
    "topic": "Syntax",
    "category": "Unsafe & Pointers",
    "title": "Enable Unsafe Code",
    "description": "Must be enabled in project settings to use unsafe code.",
    "code": "// In .csproj file\n<AllowUnsafeBlocks>true</AllowUnsafeBlocks>",
    "tags": ["syntax", "unsafe", "project", "settings"]
  }
]
